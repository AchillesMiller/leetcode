# leetcode

## index

| category            | id                                                                                  | problem statement                                                                     | supposed solution                                                                                                                                 | 
|---------------------|-------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------|
| two pointers        | [1423](include/array/two_pointers/1423.maximum_points_you_can_obstain_from_cards.h) | Given an array and k, either select front and back, get maximum sum                   | find minimum sum in middle                                                                                                                        |
| two pointers        | [1610](include/array/two_pointers/1610.maximum_number_of_visible_points.h)          | Find maximum points with an angle                                                     | sorted the angle for each point and use two pointers algorithm to find maximum points                                                             |
| two pointers        | [44](include/array/two_pointers/44.wildcard_matching.h)                             | If fails matching, always back trace to the last star                                 |                                                                                                                                                   |
| two pointers        | [768](include/array/two_pointers/768.max_chunks_to_make_sorted_II.h)                | Find partitions, after sorting and concatenating, can get a sorted array              | If the max right is less than/equal to min left, ++count;                                                                                         |
| monotonic queue     | [84](include/monotonic_queue/rectangle/84.largest_rectangle_in_histogram.h)         | Find largest area of rectangle in a histogram                                         | monotonic queue                                                                                                                                   |
| monotonic queue     | [85](include/monotonic_queue/rectangle/85.maximal_rectangle.h)                      | Find largest area of rectangle in a matrix                                            | for each row, calculate heights and turning into problem 84                                                                                       |
| dijkstra            | [787](include/dijkstra/787.cheapest_flights_within_k_stops.h)                       | Find the min costs within k stops from src to dest                                    | min cost from src to dest, this is Dijistra problem                                                                                               |
| dijkstra            | [499](include/dijkstra/maze/499.the_maze_III.h)                                     | Ball can only turn when hitting wall, use DIJKSTRA and treats each stop as node       |                                                                                                                                                   |
| dijkstra            | [505](include/dijkstra/maze/505.the_maze_II.h)                                      | Ball can only turn when hitting wall, find shortest path                              |                                                                                                                                                   |
| dfs                 | [39](include/dfs/array/combinations/39.combination_sum.h)                           | Find all combinations(distinct candidate + unlimited use)                             |                                                                                                                                                   |
| dfs                 | [40](include/dfs/array/combinations/40.combination_sum_II.h)                        | Find all combinations(non-distinct candidate + one use)                               | like a tree, when append node as child, two same value is not necessary to push as the same child of its parent                                   |
| dynamic programming | [1937](include/dp/1937.maximum_number_of_points_with_cost.h)                        | Find maximum points with cost-abs(col_1-col2)                                         | dynamic programming with two passes                                                                                                               |
| dynamic programming | [377](include/dp/377.combination_sum_iv.h)                                          | Given nums and target, find the number of combination of which sum == target          | dp[target] = âˆ‘( dp[target - nums[i]] )                                                                                                            |
| dynamic programming | [322](include/dp/knapsack/322.coin_change.h)                                        | Given coins and target, return the fewest coin combination                            | dp[target] = min( dp[target - num[i]] ) + 1                                                                                                       |
| dynamic programming | [44](include/dp/44.wildcard_matching.h)                                             | Given string and pattern, find is matching                                            | dp[i][j] = dp[i-1][j-1] if s[i] == p[j] or p[j] == '?'; = dp[i][j-1] or dp[i-1][j] if p[j] == '*                                                  |
| heap                | [632](include/heap/632.smallest_range_covering_elements_from_k_lists.h)             | Give a list of vector, find smallest range covering all elements from k lists         | any kind of sorted structure to keep exactly one element from k lists, when popping smallest number, push the next number in corresponding vector |
| heap                | [23](include/heap/linked_list/23.merge_k_sorted_lists.h)                            | Given k sorted linked list, merge into one                                            | more straightforward solution to use priority_queue, which is easier version of 632                                                               |
| matrix              | [240](include/matrix/240.search_a_2d_matrix_II.h)                                   | Given matrix of which matrix[r+1][c] > matrix[r][c] and matrix[r][c+1] > matrix[r][c] | from bottom right, go up and right till we cannot go anymore                                                                                      |
| binary search       | [4](include/binary_search/4.median_of_two_sorted_arrays.h)                          | Find median of two sorted array                                                       | find the k-th smallest value, if the median of first array > median of second array, we can move the r of first array to get final answer         |


# TODO:

  - 727. Minimum Window Subsequence
  - 307. Range Sum Query - Mutable (segment tree and binary indexed tree)
